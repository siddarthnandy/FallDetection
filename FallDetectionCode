/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/13d1ae46-aecb-47b4-bf28-7926a38efa36

  Arduino IoT Cloud Variables description+

  The following variables are automatically generated and updated when changes are made to the Thing

  bool trigger;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <siddarthn-project-1_inferencing.h>
#include <Arduino_LSM6DSOX.h> //Click here to get the library: http://librarymanager/All#Arduino_LSM6DSOX
int buzzer = 2;
int button = 3;
bool fell = false;

int val;
int state;
int count;
enum sensor_status {
  NOT_USED = -1,
  NOT_INIT,
  INIT,
  SAMPLED
};

/** Struct to link sensor axis name to sensor value function */
typedef struct {
  const char *name;
  float *value;
  uint8_t (*poll_sensor)(void);
  bool (*init_sensor)(void);
  int8_t status;  // -1 not used 0 used(unitialized) 1 used(initalized) 2 data sampled
} eiSensors;

/* Constant defines -------------------------------------------------------- */
#define CONVERT_G_TO_MS2    9.80665f
#define MAX_ACCEPTED_RANGE  4.0f        // starting 03/2022, models are generated setting range to +-2,
// but this example use Arudino library which set range to +-4g.
// If you are using an older model, ignore this value and use 4.0f instead
/** Number sensor axes used */
#define N_SENSORS     7

/* Forward declarations ------------------------------------------------------- */
float ei_get_sign(float number);
static bool ei_connect_fusion_list(const char *input_list);

bool init_IMU(void);
uint8_t poll_acc(void);
uint8_t poll_gyr(void);
uint8_t poll_mag(void);
uint8_t poll_temp(void);

/* Private variables ------------------------------------------------------- */
static const bool debug_nn = false; // Set this to true to see e.g. features generated from the raw signal
static float data[N_SENSORS];
static int8_t fusion_sensors[N_SENSORS];
static int fusion_ix = 0;

/** Used sensors value function connected to label name */
eiSensors sensors[] =
{
  "accX", &data[0], &poll_acc, &init_IMU, NOT_USED,
  "accY", &data[1], &poll_acc, &init_IMU, NOT_USED,
  "accZ", &data[2], &poll_acc, &init_IMU, NOT_USED,
  "gyrX", &data[3], &poll_gyr, &init_IMU, NOT_USED,
  "gyrY", &data[4], &poll_gyr, &init_IMU, NOT_USED,
  "gyrZ", &data[5], &poll_gyr, &init_IMU, NOT_USED,
  "temperature", &data[6], &poll_temp, &init_IMU, NOT_USED,
};

/**
  @brief      Arduino setup function
*/

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);

  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  pinMode(buzzer, OUTPUT);
  pinMode(button, INPUT);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  Serial.println("Edge Impulse Sensor Fusion Inference\r\n");

  /* Connect used sensors */
  if (ei_connect_fusion_list(EI_CLASSIFIER_FUSION_AXES_STRING) == false) {
    ei_printf("ERR: Errors in sensor list detected\r\n");
    return;
  }

  /* Init & start sensors */

  for (int i = 0; i < fusion_ix; i++) {
    if (sensors[fusion_sensors[i]].status == NOT_INIT) {
      sensors[fusion_sensors[i]].status = (sensor_status)sensors[fusion_sensors[i]].init_sensor();
      if (!sensors[fusion_sensors[i]].status) {
        ei_printf("%s axis sensor initialization failed.\r\n", sensors[fusion_sensors[i]].name);
      }
      else {
        ei_printf("%s axis sensor initialization successful.\r\n", sensors[fusion_sensors[i]].name);
      }
    }
  }
}
/**
  @brief      Get data and run inferencing
*/
void loop() {

  ArduinoCloud.update();

  val = Serial.read();
  count = 0;
  state = digitalRead(button);

  // Your code here
  ei_printf("\nStarting inferencing in 2 seconds...\r\n");

  trigger = false;


  if (EI_CLASSIFIER_RAW_SAMPLES_PER_FRAME != fusion_ix) {
    ei_printf("ERR: Sensors don't match the sensors required in the model\r\n"
              "Following sensors are required: %s\r\n", EI_CLASSIFIER_FUSION_AXES_STRING);
    return;
  }

  ei_printf("Sampling...\r\n");

  // Allocate a buffer here for the values we'll read from the sensor
  float buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE] = { 0 };

  for (size_t ix = 0; ix < EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE; ix += EI_CLASSIFIER_RAW_SAMPLES_PER_FRAME) {
    // Determine the next tick (and then sleep later)
    int64_t next_tick = (int64_t)micros() + ((int64_t)EI_CLASSIFIER_INTERVAL_MS * 1000);

    for (int i = 0; i < fusion_ix; i++) {
      if (sensors[fusion_sensors[i]].status == INIT) {
        sensors[fusion_sensors[i]].poll_sensor();
        sensors[fusion_sensors[i]].status = SAMPLED;
      }
      if (sensors[fusion_sensors[i]].status == SAMPLED) {
        buffer[ix + i] = *sensors[fusion_sensors[i]].value;
        sensors[fusion_sensors[i]].status = INIT;
      }
    }

    int64_t wait_time = next_tick - (int64_t)micros();

    if (wait_time > 0) {
      delayMicroseconds(wait_time);
    }
  }

  // Turn the raw buffer in a signal which we can the classify
  signal_t signal;
  int err = numpy::signal_from_buffer(buffer, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);
  if (err != 0) {
    ei_printf("ERR:(%d)\r\n", err);
    return;
  }

  // Run the classifier
  ei_impulse_result_t result = { 0 };

  err = run_classifier(&signal, &result, debug_nn);
  if (err != EI_IMPULSE_OK) {
    ei_printf("ERR:(%d)\r\n", err);
    return;
  }
  print_inference_result(result);

  if (state == HIGH) {
    count = count + 1;

  }
  
  delay(2000);

  if ((count > 0) && (fell == true)) {
    digitalWrite(buzzer, LOW);
    trigger = false;
    fell = false;



  }

 
  
  if ((count == 0) && (fell == true)) {
  digitalWrite(buzzer, HIGH);
  trigger = true;
  fell = true;
  Serial.println("SENT");
  delay(3000);
  ArduinoCloud.update();


  }

  Serial.print(trigger);
  Serial.println(count);



}


/*
  Since Trigger is READ_WRITE variable, onTriggerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTriggerChange()  {
  // Add your code here to act upon Trigger change
}
/**
   @brief Go through sensor list to find matching axis name

   @param axis_name
   @return int8_t index in sensor list, -1 if axis name is not found
*/
static int8_t ei_find_axis(char *axis_name)
{
  int ix;
  for (ix = 0; ix < N_SENSORS; ix++) {
    if (strstr(axis_name, sensors[ix].name)) {
      return ix;
    }
  }
  return -1;
}

/**
   @brief Check if requested input list is valid sensor fusion, create sensor buffer

   @param[in]  input_list      Axes list to sample (ie. "accX + gyrY + magZ")
   @retval  false if invalid sensor_list
*/
static bool ei_connect_fusion_list(const char *input_list)
{
  char *buff;
  bool is_fusion = false;

  /* Copy const string in heap mem */
  char *input_string = (char *)ei_malloc(strlen(input_list) + 1);
  if (input_string == NULL) {
    return false;
  }
  memset(input_string, 0, strlen(input_list) + 1);
  strncpy(input_string, input_list, strlen(input_list));

  /* Clear fusion sensor list */
  memset(fusion_sensors, 0, N_SENSORS);
  fusion_ix = 0;

  buff = strtok(input_string, "+");

  while (buff != NULL) { /* Run through buffer */
    int8_t found_axis = 0;

    is_fusion = false;
    found_axis = ei_find_axis(buff);

    if (found_axis >= 0) {
      if (fusion_ix < N_SENSORS) {
        fusion_sensors[fusion_ix++] = found_axis;
        sensors[found_axis].status = NOT_INIT;
      }
      is_fusion = true;
    }

    buff = strtok(NULL, "+ ");
  }

  ei_free(input_string);

  return is_fusion;
}

/**
   @brief Return the sign of the number

   @param number
   @return int 1 if positive (or 0) -1 if negative
*/
float ei_get_sign(float number) {
  return (number >= 0.0) ? 1.0 : -1.0;
}

bool init_IMU(void) {
  static bool init_status = false;
  if (!init_status) {
    init_status = IMU.begin();
  }
  return init_status;
}

uint8_t poll_acc(void) {

  if (IMU.accelerationAvailable()) {

    IMU.readAcceleration(data[0], data[1], data[2]);

    for (int i = 0; i < 3; i++) {
      if (fabs(data[i]) > MAX_ACCEPTED_RANGE) {
        data[i] = ei_get_sign(data[i]) * MAX_ACCEPTED_RANGE;
      }
    }

    data[0] *= CONVERT_G_TO_MS2;
    data[1] *= CONVERT_G_TO_MS2;
    data[2] *= CONVERT_G_TO_MS2;
  }

  return 0;
}

uint8_t poll_gyr(void) {

  if (IMU.gyroscopeAvailable()) {
    IMU.readGyroscope(data[3], data[4], data[5]);
  }
  return 0;
}

uint8_t poll_temp(void) {

  if (IMU.temperatureAvailable()) {
    int temp;
    IMU.readTemperature(temp);
    data[6] = temp;
  }
  return 0;
}


bool print_inference_result(ei_impulse_result_t result) {
  // Print how long it took to perform inference
  ei_printf("Timing: DSP %d ms, inference %d ms, anomaly %d ms\r\n",
            result.timing.dsp,
            result.timing.classification,
            result.timing.anomaly);

  ei_printf("Predictions:\r\n");

  // Initialize variables to keep track of the highest confidence
  uint16_t max_index = 0;
  float max_confidence = result.classification[0].value;

  for (uint16_t i = 0; i < EI_CLASSIFIER_LABEL_COUNT; i++) {
    ei_printf("  %s: %.5f\r\n", ei_classifier_inferencing_categories[i], result.classification[i].value);

    // Update max_index and max_confidence if a higher confidence is found
    if (result.classification[i].value > max_confidence) {
      max_index = i;
      max_confidence = result.classification[i].value;
    }
  }

  // Print the class with the highest confidence
  ei_printf("Highest Confidence: %s with %.5f\r\n", ei_classifier_inferencing_categories[max_index], max_confidence);
  Serial.println(ei_classifier_inferencing_categories[max_index]);

  // Check if the highest confidence class is "Fall"
  if (strcmp(ei_classifier_inferencing_categories[max_index], "Fall") == 0) {
    // Set the fall variable to true
    fell = true;
    Serial.println("PASSED");
  }


  // Print anomaly result (if it exists)
#if EI_CLASSIFIER_HAS_ANOMALY == 1
  ei_printf("Anomaly prediction: %.3f\r\n", result.anomaly);
#endif
  return fell;
}



#if !defined(EI_CLASSIFIER_SENSOR) || (EI_CLASSIFIER_SENSOR != EI_CLASSIFIER_SENSOR_FUSION && EI_CLASSIFIER_SENSOR != EI_CLASSIFIER_SENSOR_ACCELEROMETER)
#error "Invalid model for current sensor"
#endif
